<!DOCTYPE html>
<html>

  <!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="High-performance dynamic image server in Java
">

  <title>
    Cantaloupe Image Server
    
      :: Sources
    
  </title>

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/cantaloupe/css/syntax.css">
  <link rel="stylesheet" href="/cantaloupe/css/manual.css">

  <script src="/cantaloupe/scripts/jquery.min.js"></script>

</head>


  <body>

    <nav class="navbar navbar-expand-md navbar-dark bg-primary">
  <a class="navbar-brand" href="/cantaloupe/">
    <img alt="Cantaloupe" src="/cantaloupe/images/cantaloupe.png" width="40">
  </a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-items" aria-controls="navbar-items" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbar-items">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle  active " href="#" id="user-manual-dropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
          User Manual
        </a>
        <div class="dropdown-menu" aria-labelledby="user-manual-dropdown">
          <a class="dropdown-item" href="/cantaloupe/manual/4.1/getting-started.html">4.1</a>
          <a class="dropdown-item" href="/cantaloupe/manual/4.0/getting-started.html">4.0</a>
          <a class="dropdown-item" href="/cantaloupe/manual/3.4/getting-started.html">3.4</a>
          <a class="dropdown-item" href="/cantaloupe/manual/3.3/getting-started.html">3.3</a>
          <a class="dropdown-item" href="/cantaloupe/manual/3.2/getting-started.html">3.2</a>
          <a class="dropdown-item" href="/cantaloupe/manual/3.1/getting-started.html">3.1</a>
          <a class="dropdown-item" href="/cantaloupe/manual/3.0/getting-started.html">3.0</a>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://github.com/medusa-project/cantaloupe/">GitHub</a>
      </li>
    </ul>

    <ul class="navbar-nav ml-md-auto">
      <li class="nav-item">
        <a href="https://github.com/medusa-project/cantaloupe/releases.atom" title="Subscribe to Releases">
          <img width="22" height="22" src="/cantaloupe/images/feed.svg">
        </a>
      </li>
    </ul>
  </div>
</nav>


    <div class="container-fluid">
      <div class="row">
  <div class="col-sm-4 col-md-3 col-lg-2 d-print-none">
    <div class="card">
  <h5 class="card-header version">4.1</h5>
  <div class="list-group list-group-flush">
    <a class="list-group-item list-group-item-action " href="getting-started.html">Getting Started</a>

    <a class="list-group-item list-group-item-action " href="configuration.html">Configuration</a>

    <a class="list-group-item list-group-item-action " href="endpoints.html">Endpoints</a>

    <a class="list-group-item list-group-item-action " href="images.html">Images</a>

    <a class="list-group-item list-group-item-action  active " href="sources.html">Sources</a>

    <a class="list-group-item list-group-item-action " href="processors.html">Processors</a>

    <a class="list-group-item list-group-item-action " href="caching.html">Caching</a>

    <a class="list-group-item list-group-item-action " href="access-control.html">Access Control</a>

    <a class="list-group-item list-group-item-action " href="delegate-script.html">Delegate Script</a>

    <a class="list-group-item list-group-item-action " href="overlays.html">Overlays</a>

    <a class="list-group-item list-group-item-action " href="redaction.html">Redaction</a>

    <a class="list-group-item list-group-item-action " href="logging.html">Logging</a>

    <a class="list-group-item list-group-item-action " href="deployment.html">Deployment</a>

    <a class="list-group-item list-group-item-action " href="remote-management.html">Remote Management</a>
  </div>
</div>

  </div>
  <div class="col-sm-8 col-md-9 col-lg-10">
    <h1>Sources</h1>

<ul class="toc">
  <li><a href="#Features">Features</a></li>
  <li><a href="#Selection">Selection</a>
    <ul>
      <li><a href="#Static%20Source">Static</a></li>
      <li><a href="#Dynamic%20Sources">Dynamic</a></li>
      <li><a href="#Which%20Source%20Should%20I%20Use">Which Source Should I Use?</a></li>
    </ul>
  </li>
  <li><a href="#Implementations">Implementations</a>
    <ul>
      <li><a href="#FilesystemSource">FilesystemSource</a></li>
      <li><a href="#HttpSource">HttpSource</a></li>
      <li><a href="#S3Source">S3Source</a></li>
      <li><a href="#AzureStorageSource">AzureStorageSource</a></li>
      <li><a href="#JdbcSource">JdbcSource</a></li>
    </ul>
  </li>
</ul>

<p>Sources provide access to source images, translating request URI <a href="images.html#Identifiers">identifiers</a> into a source image locators, such as pathnames, in a particular type of underlying storage. After verifying that an underlying object exists and is accessible, a source can then provide access to it to other application components in a generalized way.</p>

<h2 id="Features">Features</h2>

<p>All sources can provide access to streams from which to read a resource, but only <a href="#FilesystemSource">FilesystemSource</a> can provide access to files. This distinction is important because <a href="processors.html#Supported%20Features">not all processors can read from streams</a>. See <a href="images.html#Considerations">Image Considerations</a> for background on why this is an issue.</p>

<p>Of the sources that provide stream accesss, not all support seeking. Seeking can be of enormous benefit when using certain processor/source format combinations that can fully exploit it, which are currently:</p>

<ul>
  <li><a href="processors.html#KakaduNativeProcessor">KakaduNativeProcessor</a> with JPEG2000</li>
  <li><a href="processors.html#Java2dProcessor">Java2dProcessor</a> or <a href="processors.html#JaiProcessor">JaiProcessor</a> with pyramidal TIFF</li>
</ul>

<table class="table table-bordered">
  <thead>
    <tr>
      <th>Source</th>
      <th>Type</th>
      <th>Seeking</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#FilesystemSource">FilesystemSource</a></td>
      <td>FileSource</td>
      <td class="bg-success">&check;</td>
    </tr>
    <tr>
      <td><a href="#HttpSource">HttpSource</a></td>
      <td>StreamSource</td>
      <td class="bg-success">&check;*</td>
    </tr>
    <tr>
      <td><a href="#S3Source">S3Source</a></td>
      <td>StreamSource</td>
      <td class="bg-success">&check;*</td>
    </tr>
    <tr>
      <td><a href="#AzureStorageSource">AzureStorageSource</a></td>
      <td>StreamSource</td>
      <td class="bg-success">&check;*</td>
    </tr>
    <tr>
      <td><a href="#JdbcSource">JdbcSource</a></td>
      <td>StreamSource</td>
      <td class="bg-danger">&times;</td>
    </tr>
  </tbody>
</table>

<p>* Using chunking</p>

<hr>

<h2 id="Selection">Selection</h2>

<p>In a typical configuration, <a href="#Static%20Source">one source will handle all requests</a>. It's also possible to <a href="#Dynamic%20Sources">select a source dynamically</a> depending on the image identifier.</p>

<h3 id="Static Source">Static Source</h3>

<p>When the <code>source.static</code> configuration key is set to the name of a source, that source will handle all requests.</p>

<h3 id="Dynamic Sources">Dynamic Sources</h3>

<p>When a static source is not flexible enough, it is also possible to serve images from different sources from the same application instance. For example, you may have some images stored on a filesystem, and others stored in an S3 bucket. <em>If you can differentiate their sources based on their identifier in code</em>&mdash;either by analyzing the identifier string, or performing some kind of service request&mdash;you can write a <a href="delegate-script.html">delegate method</a> to tell the image server which source to use for a given request.</p>

<p>To enable dynamic source selection, set the <code>source.delegate</code> configuration key to <code>true</code>, and implement the <code>source()</code> delegate method. For example:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">CustomDelegate</span>
  <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">'identifier'</span><span class="p">]</span>
    <span class="c1"># Here, you would perform some kind of analysis on `identifier`:</span>
    <span class="c1"># parse it, look it up in a web service or database...</span>
    <span class="c1"># and then return the name of the source to use to serve it.</span>
    <span class="s1">'FilesystemSource'</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h3 id="Which Source Should I Use">Which Source Should I Use?</h3>

<p><em>I want to serve images located&hellip;</em></p>

<table class="table table-bordered">
  <tr>
    <td rowspan="2">On a filesystem&hellip;</td>
    <td>&hellip;and the identifiers I use in URLs will correspond predictably to filesystem paths</td>
    <td><a href="#FilesystemSource">FilesystemSource</a> with BasicLookupStrategy</td>
  </tr>
  <tr>
    <td>&hellip;and filesystem paths will need to be looked up (in a SQL database, search server, index file, etc.) based on their identifier</td>
    <td><a href="#FilesystemSource">FilesystemSource</a> with ScriptLookupStrategy</td>
  </tr>
  <tr>
    <td rowspan="2">On a web server&hellip;</td>
    <td>&hellip;and the identifiers I use in URLs will correspond predictably to URL paths</td>
    <td><a href="#HttpSource">HttpSource</a> with BasicLookupStrategy</td>
  </tr>
  <tr>
    <td>&hellip;and URL paths will need to be looked up (in a SQL database, search server, index file, etc.) based on their identifier</td>
    <td><a href="#HttpSource">HttpSource</a> with ScriptLookupStrategy</td>
  </tr>
  <tr>
    <td rowspan="2">In S3&hellip;</td>
    <td>&hellip;and the identifiers I use in URLs will correspond predictably to object keys</td>
    <td><a href="#S3Source">S3Source</a> with BasicLookupStrategy</td>
  </tr>
  <tr>
    <td>&hellip;and object keys will need to be looked up (in a SQL database, search server, index file, etc.) based on their identifier</td>
    <td><a href="#S3Source">S3Source</a> with ScriptLookupStrategy</td>
  </tr>
  <tr>
    <td rowspan="2">In Azure Storage&hellip;</td>
    <td>&hellip;and the identifiers I use in URLs will correspond predictably to object keys</td>
    <td><a href="#AzureStorageSource">AzureStorageSource</a> with BasicLookupStrategy</td>
  </tr>
  <tr>
    <td>&hellip;and object keys will need to be looked up (in a SQL database, search server, index file, etc.) based on their identifier</td>
    <td><a href="#AzureStorageSource">AzureStorageSource</a> with ScriptLookupStrategy</td>
  </tr>
  <tr>
    <td colspan="2">As binaries or BLOBs in a SQL database</td>
    <td><a href="#JdbcSource">JdbcSource</a></td>
  </tr>
</table>

<h2 id="Implementations">Implementations</h2>

<h3 id="FilesystemSource">FilesystemSource</h3>

<p>FilesystemSource maps a URL identifier to a filesystem path, for retrieving images on a local or network-mounted filesystem. This is the most compatible source, and usually the most efficient as well.</p>

<h4>Lookup Strategies</h4>

<p>Two distinct lookup strategies are supported, defined by the <code>FilesystemSource.lookup_strategy</code> configuration option.</p>

<h5 id="FilesystemSourceBasicLookupStrategy">BasicLookupStrategy</h5>

<p>BasicLookupStrategy locates images by concatenating an identifier with a pre-defined path prefix and/or suffix. For example, with the following configuration options set:</p>

<figure class="highlight"><pre><code class="language-properties" data-lang="properties"><span class="c"># Note trailing slash!
</span><span class="py">FilesystemSource.BasicLookupStrategy.path_prefix</span> <span class="p">=</span> <span class="s">/usr/local/images/</span>
<span class="py">FilesystemSource.BasicLookupStrategy.path_suffix</span> <span class="p">=</span></code></pre></figure>

<p>An identifier of <span class="filename">image.jpg</span> in the URL will resolve to
<span class="filename">/usr/local/images/image.jpg</span>.</p>

<p>It's also possible to include a partial path in the identifier using URL-encoded slashes (<code>%2F</code>) as path separators. <span class="filename">subdirectory%2Fimage.jpg</span> in the URL would then resolve to <span class="filename">/usr/local/images/subdirectory/image.jpg</span>.</p>

<p class="text-info">
  <i class="fa fa-info-circle"></i> If you are operating behind a reverse proxy that is not capable of passing encoded URL characters through without decoding them, see the <code>slash_substitute</code> configuration key.
</p>

<p>To prevent arbitrary directory traversal, BasicLookupStrategy will recursively strip out <span class="filename">../</span>, <span class="filename">/..</span>, <span class="filename">..\</span>, and <span class="filename">\..</span> from identifiers before resolving the path.</p>

<div class="alert alert-danger">
  <i class="fa fa-warning"></i> Consider setting <code>FilesystemSource.BasicLookupStrategy.path_prefix</code> as deep as possible. The shallower the path, the more of the filesystem that will be exposed.
</div>

<h5 id="FilesystemSourceScriptLookupStrategy">ScriptLookupStrategy</h5>

<p>Sometimes, BasicLookupStrategy will not offer enough control. Perhaps you want to serve images from multiple filesystems, or perhaps your identifiers are opaque and you need to perform a database or web service request to locate the corresponding images. With this lookup strategy, you can tell FilesystemSource to invoke a <a href="delegate-script.html">delegate method</a> and capture the pathname it returns.</p>

<p>The delegate method, <code>filesystemsource_pathname()</code>, should return a pathname if available, or <code>nil</code> if not. Examples follow:</p>

<h5>Example 1: Query a PostgreSQL database to find the pathname corresponding to a given identifier</h5>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'java'</span>

<span class="n">java_import</span> <span class="s1">'org.postgresql.Driver'</span>
<span class="n">java_import</span> <span class="s1">'java.sql.DriverManager'</span>

<span class="k">class</span> <span class="nc">CustomDelegate</span>

  <span class="no">JDBC_URL</span> <span class="o">=</span> <span class="s1">'jdbc:postgresql://localhost:5432/mydatabase'</span>
  <span class="no">JDBC_USER</span> <span class="o">=</span> <span class="s1">'myuser'</span>
  <span class="no">JDBC_PASSWORD</span> <span class="o">=</span> <span class="s1">'mypassword'</span>

  <span class="c1"># By making the connection static, we can avoid reconnecting every time</span>
  <span class="c1"># the method is called, which would be expensive.</span>
  <span class="c1"># See: https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html</span>
  <span class="vc">@@conn</span> <span class="o">=</span> <span class="no">DriverManager</span><span class="p">.</span><span class="nf">get_connection</span><span class="p">(</span><span class="no">JDBC_URL</span><span class="p">,</span> <span class="no">JDBC_USER</span><span class="p">,</span> <span class="no">JDBC_PASSWORD</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">filesystemsource_pathname</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">'identifier'</span><span class="p">]</span>
    <span class="k">begin</span>
      <span class="c1"># Note the use of prepared statements, which are safer than</span>
      <span class="c1"># string concatenation.</span>
      <span class="n">sql</span> <span class="o">=</span> <span class="s1">'SELECT pathname FROM images WHERE identifier = ? LIMIT 1'</span>
      <span class="n">stmt</span> <span class="o">=</span> <span class="vc">@@conn</span><span class="p">.</span><span class="nf">prepare_statement</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
      <span class="n">stmt</span><span class="p">.</span><span class="nf">set_string</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
      <span class="n">results</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">.</span><span class="nf">execute_query</span>
      <span class="n">results</span><span class="p">.</span><span class="nf">next</span>
      <span class="n">pathname</span> <span class="o">=</span> <span class="n">results</span><span class="p">.</span><span class="nf">getString</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">pathname</span><span class="p">.</span><span class="nf">present?</span> <span class="p">?</span> <span class="n">pathname</span> <span class="p">:</span> <span class="kp">nil</span>
    <span class="k">ensure</span>
      <span class="n">stmt</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Note that several common Ruby database libraries (like the mysql and pgsql gems) use native extensions. These won't work in JRuby. Instead, the course of action above is to use the JDBC API via the JRuby-Java bridge. For this to work, a JDBC driver for your database must be installed on the Java classpath, and referenced in a <code>java_import</code> statement.</p>

<h5>Example 2: Query a web service to find the pathname corresponding to a given identifier</h5>

<p>This very simple mock web service returns a pathname in the response body when an image exists, and an empty response body if not.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'net/http'</span>
<span class="nb">require</span> <span class="s1">'cgi'</span>

<span class="k">class</span> <span class="nc">CustomDelegate</span>
  <span class="k">def</span> <span class="nf">filesystemsource_pathname</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">'identifier'</span><span class="p">]</span>
    <span class="n">uri</span> <span class="o">=</span> <span class="s1">'http://example.org/webservice/'</span> <span class="o">+</span> <span class="no">CGI</span><span class="p">.</span><span class="nf">escape</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>
    <span class="n">uri</span> <span class="o">=</span> <span class="no">URI</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>

    <span class="n">http</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">uri</span><span class="p">.</span><span class="nf">host</span><span class="p">,</span> <span class="n">uri</span><span class="p">.</span><span class="nf">port</span><span class="p">)</span>
    <span class="n">request</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="o">::</span><span class="no">Get</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">uri</span><span class="p">.</span><span class="nf">request_uri</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="nf">request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">response</span><span class="p">.</span><span class="nf">code</span><span class="p">.</span><span class="nf">to_i</span> <span class="o">&gt;=</span> <span class="mi">400</span>

    <span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">present?</span> <span class="p">?</span> <span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">strip</span> <span class="p">:</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h4>Format Inference</h4>

<p>Like all sources, FilesystemSource needs to be able to figure out the format of a source image before it can be served. It uses the following strategy to do this:</p>

<ol>
  <li>If the file's filename contains an extension, the format is inferred from that.</li>
  <li>If unsuccessful, and the identifier contains a filename extension, the format is inferred from that.</li>
  <li>If unsuccessful, an attempt is made to infer a format from the file's magic bytes.</li>
</ol>

<hr>

<h3 id="HttpSource">HttpSource</h3>

<p>HttpSource maps a URL identifier to an HTTP or HTTPS resource, for retrieving images from a remote web server. It uses a <a href="http://www.eclipse.org/jetty/documentation/current/http-client.html">Jetty HTTP client</a> internally.</p>

<h4>Lookup Strategies</h4>

<p>HttpSource supports two distinct lookup strategies, defined by the <code>HttpSource.lookup_strategy</code> configuration option.</p>

<h5 id="HttpSourceBasicLookupStrategy">BasicLookupStrategy</h5>

<p>BasicLookupStrategy locates images by concatenating an identifier with a pre-defined URL prefix and/or suffix. For example, with the following configuration options set:</p>

<figure class="highlight"><pre><code class="language-properties" data-lang="properties"><span class="c"># Note trailing slash!
</span><span class="py">HttpSource.BasicLookupStrategy.url_prefix</span> <span class="p">=</span> <span class="s">http://example.org/images/</span>
<span class="py">HttpSource.BasicLookupStrategy.url_suffix</span> <span class="p">=</span></code></pre></figure>

<p>An identifier of <span class="filename">image.jpg</span> in the URL will resolve to
<span class="filename">http://example.org/images/image.jpg</span>.</p>

<p>A partial path can be included in the identifier by URL-encoding the path separator slashes (<code>%2F</code>). <span class="filename">subpath%2Fimage.jpg</span> in the URL would then resolve to <span class="filename">http://example.org/images/subpath/image.jpg</span>.</p>

<p>It's also possible to use a full URL as an identifier by leaving both of the above keys blank. In that case, an identifier of <span class="filename">http%3A%2F%2Fexample.org%2Fimages%2Fimage.jpg</span> in the URL will resolve to
<span class="filename">http://example.org/images/image.jpg</span>.</p>

<p class="text-info">
  <i class="fa fa-info-circle"></i> If you are operating behind a reverse proxy that is not capable of passing encoded URL characters through without decoding them, see the <code>slash_substitute</code> configuration key.
</p>

<h5 id="HttpSourceScriptLookupStrategy">ScriptLookupStrategy</h5>

<p>Sometimes, BasicLookupStrategy will not offer enough control. Perhaps you want to serve images from multiple URLs, or perhaps your identifiers are opaque and you need to run a database or web service request to locate them.  With this lookup strategy, you can tell HttpSource to invoke the <code>httpsource_resource_info()</code> <a href="delegate-script.html">delegate method</a> and capture the request info (URL and optionally authentication credentials and/or request headers) it returns.</p>

<p>See the <a href="#FilesystemSourceScriptLookupStrategy">FilesystemSource ScriptLookupStrategy</a> section for examples of similar methods.</p>

<h4>Authentication</h4>

<p>HTTP Basic authentication is supported.</p>

<ul>
  <li>When using <a href="#HttpSourceBasicLookupStrategy">BasicLookupStrategy</a>, auth info is set globally in the <code>HttpSource.BasicLookupStrategy.auth.basic.username</code> and <code>HttpSource.BasicLookupStrategy.auth.basic.secret</code> configuration keys.</li>
  <li>When using <a href="#HttpSourceScriptLookupStrategy">ScriptLookupStrategy</a>, auth info can be returned from the delegate method.</li>
</ul>

<h4>Format Inference</h4>

<p>Like all sources, HttpSource needs to be able to figure out the format of a source image before it can be served. It uses the strategy below to do this.</p>

<ol>
  <li>If the path component of the URI that HttpSource is trying to access contains an extension, the format is inferred from that.</li>
  <li>If unsuccessful, and the identifier has a filename extension, the format is inferred from that.</li>
  <li>If unsuccessful, and if the <code>HEAD</code> response contains a <code>Content-Type</code> header with a recognized value that is specific enough (not <code>application/octet-stream</code>, for example), a format is inferred from that.</li>
  <li>If unsuccessful, and if the <code>HEAD</code> response contains an <code>Accept-Ranges: bytes</code> header, a <code>GET</code> request is sent containing a <code>Range</code> header specifying a small range of data from the beginning of the resource, and a format is inferred from the magic bytes in the response entity.</li>
  <li>If still unsuccessful, the request fails.</li>
</ol>

<h4 id="HttpSourceSeeking">Seeking</h4>

<p>Since version 4.1, this source is able to facilitate seeking by requesting small chunks of image data as needed, as opposed to all of it. This may improve efficiency&mdash;possibly massively&mdash;when reading small portions of large images in certain formats (see below). Conversely, it may reduce efficiency when reading large portions of images, but this use case is probably less common.</p>

<p>In order for this technique to work:</p>

<ol>
  <li>The <code>HttpSource.chunking.enabled</code> configuration key must be set to <code>true</code>;</li>
  <li>The HTTP server must support the <code>Range</code> header, as advertised by the presence of an <code>Accept-Ranges: bytes</code> header in a <code>HEAD</code> response;</li>
  <li>One of the following processor/source format combinations must be used:
    <ul>
      <li><a href="processors.html#KakaduNativeProcessor">KakaduNativeProcessor</a> with JPEG2000</li>
      <li><a href="processors.html#Java2dProcessor">Java2dProcessor</a> or <a href="processors.html#JaiProcessor">JaiProcessor</a> with multi-resolution TIFF</li>
    </ul>
  </li>
</ol>

<p>Note that when chunking is in effect, the <code>processor.stream_retrieval_strategy</code> configuration key is ignored, effectively behaving as if it were set to <code>StreamStrategy</code>. (See <a href="processors.html#Retrieval%20Strategies">Retrieval Strategies</a>.) Chunking is meant to obviate the expense of the other strategies.</p>

<hr>

<h3 id="S3Source">S3Source</h3>

<p>S3Source maps a URL identifier to an <a href="https://aws.amazon.com/s3/">Amazon Simple Storage Service (S3)</a> object, for retrieving images from S3. S3Source can work with both AWS and non-AWS S3 endpoints.</p>

<h4 id="S3SourceCredentialsSources">Credentials Sources</h4>

<p>S3Source can obtain its credentials from several different sources. It will first consult the <code>S3Source.access_key_id</code> and  <code>S3Source.secret_key</code> keys in the application configuration. If those are not set, it will fall back to the strategy employed by the AWS SDK's <code>DefaultAWSCredentialsProviderChain</code>; see its <a href="https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/index.html?com/amazonaws/auth/DefaultAWSCredentialsProviderChain.html">class documentation</a> for details.</p>

<h4 id="S3SourceLookupStrategies">Lookup Strategies</h4>

<h5 id="S3SourceBasicLookupStrategy">BasicLookupStrategy</h5>

<p>BasicLookupStrategy locates images by concatenating an identifier with a pre-defined path prefix and/or suffix. For example, with the following configuration options set:</p>

<figure class="highlight"><pre><code class="language-properties" data-lang="properties"><span class="c"># Note trailing slash!
</span><span class="py">S3Source.BasicLookupStrategy.path_prefix</span> <span class="p">=</span> <span class="s">path/prefix/</span>
<span class="py">S3Source.BasicLookupStrategy.path_suffix</span> <span class="p">=</span></code></pre></figure>

<p>An identifier of <span class="filename">image.jpg</span> in the URL will resolve to
<span class="filename">path/prefix/image.jpg</span> within the bucket.</p>

<p>It's also possible to include a partial path in the identifier using URL-encoded slashes (<code>%2F</code>) as path separators. <span class="filename">subpath%2Fimage.jpg</span> in the URL would then resolve to <span class="filename">path/prefix/subpath/image.jpg</span>.</p>

<p class="text-info">
  <i class="fa fa-info-circle"></i> If you are operating behind a reverse proxy that is not capable of passing encoded URL characters through without decoding them, see the <code>slash_substitute</code> configuration key.
</p>

<h5 id="S3SourceScriptLookupStrategy">ScriptLookupStrategy</h5>

<p>When your URL identifiers don't match your S3 object keys, ScriptLookupStrategy is available to tell S3Source to capture the object key returned by a method in your <a href="delegate-script.html">delegate script</a>. The <code>s3source_object_info()</code> method should return a hash containing <code>bucket</code> and <code>key</code> keys, if an object is available, or <code>nil</code> if not. See the <a href="#FilesystemSourceScriptLookupStrategy">FilesystemSource ScriptLookupStrategy</a> section for examples of similar methods.</p>

<h4>Format Inference</h4>

<p>Like all sources, S3Source needs to be able to figure out the format of a source image before it can be served. It uses the following strategy to do this:</p>

<ol>
  <li>If the object key has a recognized filename extension, the format is inferred from that.</li>
  <li>Otherwise, if the source image's URI identifier has a recognized filename extension, the format is inferred from that.</li>
  <li>Otherwise, a <code>GET</code> request is sent with a <code>Range</code> header specifying a small range of data from the beginning of the resource.
    <ol>
      <li>If a <code>Content-Type</code> header is present in the response, and is specific enough (i.e. not <code>application/octet-stream</code>), a format is inferred from that.</li>
      <li>Otherwise, a format is inferred from the magic bytes in the response body.</li>
    </ol>
  </li>
</ol>

<h4>Seeking</h4>

<p>This source supports seeking since version 4.1. See the <a href="#HttpSourceSeeking">HttpSource</a> section for an explanation of this feature.</p>

<hr>

<h3 id="AzureStorageSource">AzureStorageSource</h3>

<p>AzureStorageSource maps a URL identifier to a <a href="https://azure.microsoft.com/en-us/services/storage/">Microsoft Azure Blob Storage</a> blob, for retrieving images from Azure Blob Storage.</p>

<h4>Lookup Strategies</h4>

<h5 id="AzureStorageSourceBasicLookupStrategy">BasicLookupStrategy</h5>

<p>BasicLookupStrategy locates images by passing the URL identifier as-is to Azure Storage, with no additional configuration possible.</p>

<h5 id="AzureStorageSourceScriptLookupStrategy">ScriptLookupStrategy</h5>

<p>When your URL identifiers don't match your blob keys, ScriptLookupStrategy is available to tell AzureStorageSource to capture the blob key returned by a method in your <a href="delegate-script.html">delegate script</a>.</p>

<p>The delegate method, <code>azurestoragesource_blob_key()</code>, should return a blob key string if available, or <code>nil</code> if not. See the <a href="#FilesystemSourceScriptLookupStrategy">FilesystemSource ScriptLookupStrategy</a> section for examples of similar methods.</p>

<h4>Format Inference</h4>

<p>Like all sources, AzureStorageSource needs to be able to figure out the format of a source image before it can be served. It uses the following strategy to do this:</p>

<ol>
  <li>If the blob key has a recognized filename extension, the format is inferred from that.</li>
  <li>Otherwise, if the source image's URI identifier has a recognized filename extension, the format is inferred from that.</li>
  <li>Otherwise, a <code>HEAD</code> request is sent. If a <code>Content-Type</code> header is present in the response, and is specific enough (i.e. not <code>application/octet-stream</code>), a format is inferred from that.</li>
  <li>Otherwise, a <code>GET</code> request is sent with a <code>Range</code> header specifying a small range of data from the beginning of the resource, and a format is inferred from the magic bytes in the response body.</li>
</ol>

<h4>Seeking</h4>

<p>This source supports seeking since version 4.1. See the <a href="#HttpSourceSeeking">HttpSource</a> section for an explanation of this feature.</p>

<hr>

<h3 id="JdbcSource">JdbcSource</h3>

<p>JdbcSource maps a URL identifier to a BLOB field, for retrieving images from a relational database. It does not require a custom schema and can adapt to any schema, but some <a href="delegate-script.html">delegate methods</a> must be implemented in order to obtain the information needed to run the SQL queries.</p>

<p>The application does not include any JDBC drivers, so a driver JAR for the desired database must be obtained separately and saved somewhere on the classpath.</p>

<p>The JDBC connection is initialized by the <code>JdbcSource.url</code>, <code>JdbcSource.user</code>, and <code>JdbcSource.password</code> configuration options. If the user or password are not necessary, they can be left blank. The connection string must use your driver's JDBC syntax:</p>

<pre><code>jdbc:postgresql://localhost:5432/my_database
jdbc:mysql://localhost:3306/my_database
jdbc:microsoft:sqlserver://example.org:1433;DatabaseName=MY_DATABASE</code></pre>

<p>Consult the driver's documentation for details.</p>

<p>Then, the source needs to be told:</p>

<ol>
  <li><a href="#JdbcSourceIdentifierMethod">The database value corresponding to a given identifier</a></li>
  <li><a href="#JdbcSourceMediaTypeMethod">The media type corresponding to that value</a></li>
  <li><a href="#JdbcSourceBlobSQLMethod">The SQL statement that retrieves the BLOB value corresponding to that value</a></li>
</ol>

<h4 id="JdbcSourceIdentifierMethod">Database Identifier Retrieval Method</h4>

<p>This method takes in an unencoded URL identifier and returns the corresponding database value of the identifier.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">CustomDelegate</span>
  <span class="k">def</span> <span class="nf">jdbcsource_database_identifier</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="c1"># If URL identifiers map directly to values in the database, simply</span>
    <span class="c1"># return the identifier from the request context. Otherwise, you</span>
    <span class="c1"># could transform it, perform a service request to look it up, etc.</span>
    <span class="n">context</span><span class="p">[</span><span class="s1">'identifier'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h4 id="JdbcSourceMediaTypeMethod">Media Type Retrieval Method</h4>

<p>This method should return a media (MIME) type corresponding to the value returned by the <code><a href="#JdbcSourceIdentifierMethod">jdbcsource_database_identifier()</a></code> method. If the media type is stored in the database, this example will return an SQL statement to retrieve it.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">CustomDelegate</span>
  <span class="k">def</span> <span class="nf">jdbcsource_media_type</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="s1">'SELECT media_type '</span> <span class="o">+</span>
        <span class="s1">'FROM some_table '</span> <span class="o">+</span>
        <span class="s1">'WHERE some_identifier = ?'</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>This method may return <code>nil</code>; see <a href="#JdbcSourceFormatInference">Format Inference</a>.</p>

<h4 id="JdbcSourceBlobSQLMethod">BLOB Retrieval SQL Method</h4>

<p>This method should return an SQL statement that selects the BLOB value corresponding to the value returned by the <code><a href="#JdbcSourceIdentifierMethod">jdbcsource_database_identifier()</a></code> method.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">CustomDelegate</span>
  <span class="k">def</span> <span class="nf">jdbcsource_lookup_sql</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="s1">'SELECT image_blob_column '</span>
        <span class="s1">'FROM some_table '</span>
        <span class="s1">'WHERE some_identifier = ?'</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h4 id="JdbcSourceFormatInference">Format Inference</h4>

<p>Like all sources, JdbcSource needs to be able to figure out the format of a source image before it can be served. It uses the following strategy to do this:</p>

<ol>
  <li>If the <a href="#JdbcSourceMediaTypeMethod">media type retrieval method</a> returns either a recognized media type, or an SQL query that can be invoked to obtain a recognized media type, the corresponding format is used.</li>
  <li>If the source image's URI identifier has a recognized filename extension, the format is inferred from that.</li>
  <li>Otherwise, the <a href="#JdbcSourceBlobSQLMethod">blob retrieval SQL</a> is executed to obtain a small range of data from the beginning of the resource, and an attempt is made to infer a format from its magic bytes.</li>
</ol>

  </div>
</div>


      <footer>
</footer>

<script src="/cantaloupe/scripts/bootstrap.min.js"></script>
<script src="/cantaloupe/scripts/base.js"></script>

    </div>

  </body>

</html>
